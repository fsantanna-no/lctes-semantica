\newcommand{\NST}{\1\xrightarrow[nst]\1}
\newcommand{\OUT}{\1\xrightarrow[out]\1}
\newcommand{\LL}{\langle}
\newcommand{\RR}{\rangle}
\newcommand{\DS}{\displaystyle}

\newcommand{\1}{\;}
\newcommand{\2}{\;\;}
\newcommand{\3}{\;\;\;}
\newcommand{\5}{\;\;\;\;\;}

\section{Formal Semantics}
\label{sec.sem}

%\begin{document}

In this section, we introduce a reduced syntax of \CEU and propose an 
operational semantics to formally describe the language.
We describe a small synchronous kernel highlighting the peculiarities of \CEU, 
in particular the stack-based execution for internal events.
%
For the sake of simplicity, we focus on the control aspects of the language, 
leaving out side effects and system calls (which behave like in conventional 
imperative languages).

\subsection{Abstract Syntax}
\label{sec.sem.syntax}

\begin{lstlisting}[
  %numbers=left,
  basicstyle=\ttfamily\footnotesize,
  float=h,
  caption={Reduced syntax of \CEU.},
  label={lst.formal.syntax},
  mathescape=true
]
                                   // primary expressions
  p ::= mem(id)                    (any memory access to `id')
      $|$ awaitExt(id)               (await external event `id')
      $|$ awaitInt(id)               (await internal event `id')
      $|$ emitInt(id)                (emit internal event `id')
      $|$ break                      (loop escape)
                                   // compound expressions
      $|$ if mem(id) then p else p   (conditional)
      $|$ p ; p                      (sequence)
      $|$ loop p                     (repetition)
      $|$ p and p                    (par/and)
      $|$ p or p                     (par/or)
      $|$ fin p                      (finalization)
                                   // derived by semantic rules
      $|$ p @loop p                  (unwinded loop)
      $|$ p @and q                   (unwinded par/and)
      $|$ p @or q                    (unwinded par/or)
      $|$ @canrun(n)                 (can run on stack level `n')
      $|$ @nop                       (terminated expression)
\end{lstlisting}

Listing~\ref{lst.formal.syntax} shows the syntax for a subset of \CEU that is 
sufficient to describe all semantic peculiarities of the language.
%
Except for $fin$ and the expressions used internally by the semantics, which
are prefixed with a character $@$, all other expressions are equivalent to
their counterparts in the concrete language.

The $mem(id)$ primitive represents all accesses, assignments, system calls, and
output events that affect a memory location identified by $id$.
%
According to the synchronous hypothesis of \CEU, $mem$ expressions are 
considered to be atomic and instantaneous.
%
As the challenging parts of \CEU reside on its control structures, we are not 
concerned here with a precise semantics for side effects, but only with their 
occurrences in programs.
%
%The special notation $nop$ is used to represent an innocuous $mem$ expression 
%(it can be thought as a synonym for $mem(\epsilon)$, where $\epsilon$ is an 
%unused identifier).
%
Note that $mem$, $awaitExt$, and $awaitInt$ / $emitInt$ expressions do not
share identifiers, i.e., an identifier is either a variable, an external event,
or an internal event.

\subsection{Operational Semantics}

The core of our semantics describes how a program reacts to a single external 
input event, i.e., starting from the input event, how the program behaves and 
becomes idle again to proceed to the subsequent reaction.
%
We use a set of small-step operational rules, which are built in such a way 
that at most one transition is possible at any time, resulting in deterministic 
reactions.
%
The transition rules map a triple with a program $p$, a stack level $n$, and an
emitted event $e$ to a modified triple as follows:
%
\begin{align*}
\LL p,  n,  e  \RR &\1\xrightarrow\1
\LL p', n', e' \RR
    & \textbf{(rule-general)}
\end{align*}
%
where
%
\begin{align*}
p, p' &\in P
    && (program~as~described~in~Listing~\ref{lst.formal.syntax})
\\
n, n' &\in \mathds{N}
    && (current~stack~level)
\\
e, e' &\in \mathds{E \cup \{\epsilon\}}
    && (emitted~event,~possibly~none)
\end{align*}
%
At the beginning of a reaction to an input event, the triple is initialized at
stack level $0$ ($n=0$) and with the emitted event $id$ ($e=id$).
%, but \code{emitInt} expressions can increase the stack level.
At the end of a reaction, after a number of transitions, the triple will block
with a (possibly) modified program $p'$, at stack level $0$, with no event
emitted $\epsilon$:
%
\begin{align*}
\LL p,0,ext \RR
    & \1\xrightarrow{*}\1
\LL p',0,\epsilon \RR
\end{align*}
%
We also define two transition rule subtypes $\OUT$ (for \emph{outermost}) and
$\NST$ (for \emph{nested}).

The $\OUT$ rules \textbf{push} and \textbf{pop} are non-recursive definitions
that manipulate the stack level as follows:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \frac
    { \DS e \neq \epsilon }
%   -----------------------------------------------------------
    { \DS \LL p,n,e \RR \OUT \LL bcast(p),n+1,\epsilon \RR }
    & \textbf{(push)}   \\
%%%
& \frac
    { \DS n>0, \2 ((p=@nop) \wedge isblocked(n,p)) }
%   -----------------------------------------------------------
    { \DS \LL p,n,\epsilon \RR \OUT \LL p,n-1,\epsilon \RR }
    & \textbf{(pop)}    \\
%%%
%& \LL p,0,\epsilon \RR \1\xrightarrow\1 \bot
    %& \textbf{(end)}    %\\
\end{eqnarray*}
}
%
Rule \textbf{push} matches whenever there is an emitted event in the triple,
and instantly broadcasts the event to the program, which means
    (a) awaking active \code{await} expressions altogether (see $bcast(p)$ in
        Figure~\ref{fig.bcast}),
    (b) creating a nested reaction by increasing the stack level,
    (c) and, at the same time, consuming the event ($e$ becomes $\epsilon$).
%
Note that rule \textbf{push} is the only one in the semantics that matches an
emitted event and also immediately consumes it.
%
The rule \textbf{pop} only decreases the stack level, not affecting the
program, and does not apply if the program is not blocked (see $isblocked(n,p)$
in Figure~\ref{fig.isblocked}).
This condition ensures that an \code{emit} only resumes after its internal
reaction completes, as discussed in Section~\ref{sec.ceu.evts}.

Note that at the beginning of a reaction, an event $ext$ is emitted, which
will trigger rule \textbf{push}, which will immediately raise the stack level
to $1$.
Since rule \textbf{pop} is the only to decrease the stack level and only
applies to a blocked or terminated program, the semantics guarantees that a
reaction only terminates with a blocked program at stack level $0$.

The $\NST$ rules are recursive definitions but do not affect the stack level
and never have an emitted event as a precondition:
%
\begin{align*}
\LL p, n,\epsilon \RR &\NST
\LL p',n,e        \RR
    & \textbf{(rule-inner)}
\end{align*}
%
The distinction between $\OUT$ and $\NST$ prevents rules \textbf{push} and
\textbf{pop} to match and inadvertently modify the current stack level before
completing a nested reaction.
%
A complete reaction behaves as follows:
%
\begin{align*}
a) &\5\5
    \LL p,0,ext \RR
        \1\xrightarrow[out]{push}\1
    \LL q,1,\epsilon \RR
\\
b) &\5\5 \1[ \1\xrightarrow[in]{*}\1
    \LL r,i,e \RR
        \1\xrightarrow[out]\1
    \LL s,j,\epsilon \RR \1]*
\\
c) &\5\5 \1\xrightarrow[in]{*}\1
    \LL t,k,\epsilon \RR
        \1\xrightarrow[out]{pop}\1
    \LL u,0,\epsilon \RR
\end{align*}
%
First (case $a$), a $\xrightarrow[out]{push}$ starts a nested reaction at level
$1$.
Then (case $b$), a series of alternations between $\NST$ transitions and a
single $\OUT$ transition represent, respectively, nested reactions and stack
operations.
Finally (case $c$), at some point, a $\xrightarrow[out]{pop}$ decrements the
stack level to $0$ and terminates the reaction.

The $\NST$ transition rules for primary expressions are as follows:
%
{ \setlength{\jot}{20pt}
\begin{align*}
\LL mem(id), n, \epsilon \RR &\NST
\LL @nop, n, \epsilon \RR
    & \textbf{(mem)}        \\
%%%
\LL emit(id), n, \epsilon \RR &\NST
\LL @canrun(n), n, id \RR
    & \textbf{(emitInt)}    \\
%%%
\LL @canrun(n), n, \epsilon \RR &\NST
\LL @nop, n, \epsilon \RR
    & \textbf{(canrun)}     \\
\end{align*}
}
%
A $mem$ operation becomes a $@nop$ which indicates termination (rule
\textbf{mem}).
An $emitInt(id)$ generates an event $id$ and transits to a $@canrun(n)$ which
can only resume at level $n$ (rule \textbf{emitInt}).
Since nested rules cannot transit with $e \neq \epsilon$, this rule will cause
rule \textbf{push} to execute at the outer level, creating a new level $n+1$ on
the stack.
Also, with the new stack level, the resulting $@canrun(n)$ itself cannot
transit, providing the desired stack-based semantics for internal events.

Proceeding to compound expressions, the rules for conditionals and sequences 
are straightforward:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \frac
    { \DS val(id) \neq 0 }
%   -----------------------------------------------------------
    { \DS \LL (if~mem(id)~then~p~else~q),n,\epsilon \RR \NST
          \LL p, n, \epsilon \RR }
    & \textbf{(if-true)}       \\
%%%
& \frac
    { \DS val(id,n) = 0 }
%   -----------------------------------------------------------
    { \DS \LL (if~mem(id)~then~p~else~q),n,\epsilon \RR \NST
          \LL q,n,\epsilon \RR }
    & \textbf{(if-false)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~;~q), n, \epsilon \RR \NST \LL (p'~;~q), n, e \RR }
    & \textbf{(seq-adv)}      \\
%%%
& \LL (@nop~;~q),n,\epsilon \RR \NST  \LL q,n,\epsilon \RR
    & \textbf{(seq-nop)}      \\
%%%
& \LL (break~;~q),n,\epsilon \RR \NST \LL break,n,\epsilon \RR
    & \textbf{(seq-brk)}
\end{eqnarray*}
}
%
Given that our semantics focuses on control, rules \textbf{if-true} and 
\textbf{if-false} are the only to query $mem$ expressions.
%
Function $val$ receives a memory identifier and returns the current memory
value.
%
%Although the value here is arbitrary, it is unique in a reaction, because a 
%given expression can execute only once within it (remember that $loops$ must 
%contain $awaits$ which, from rule \textbf{await}, cannot awake in the same 
%reaction they are reached).
%For all other rules, we omit these values (e.g., \textbf{seq-nop}).

As determined for nested rules, compound expressions also can only have
$\epsilon$ as a precondition and they never modify $n$.
However, they can still emit an event to nest another reaction.
For instance, in rule \textbf{seq-adv}, if the sub-expression $p$ emits event
$e$, the whole composition also emits $e$.
%However, rules \textbf{push} and \textbf{pop} can only match at the outermost
%level.

The rules for loops are analogous to sequences, but use \code{`@'} as 
separators to properly bind breaks to their enclosing loops:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (loop~p),n,\epsilon \RR \NST \LL (p~@loop~p), n, \epsilon \RR
    & \textbf{(loop-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
% -----------------------------------------------------------
    { \DS \LL (p~@loop~q),n,\epsilon \RR \NST \LL (p'~@loop~q), n, e \RR }
    & \textbf{(loop-adv)}    \\
%%%
& \LL (@nop~@loop~p), n, \epsilon \RR \NST \LL (loop~p), n, \epsilon \RR
    & \textbf{(loop-nop)}    \\
%%%
& \LL (break~@loop~p), n, \epsilon \RR \NST \LL @nop, n, \epsilon \RR
    & \textbf{(loop-brk)}
\end{eqnarray*}
}

%
When a program encounters a $loop$, it first expands its body in sequence with 
itself (rule \textbf{loop-expd}).
Rules \textbf{loop-adv} and \textbf{loop-nop} are similar to rules 
\textbf{seq-adv} and \textbf{seq-nop}, advancing the loop until they reach a 
$@nop$.
However, what follows the loop is the loop itself (rule \textbf{loop-nop}).
Note that if we used \code{`;'} as a separator in loops, rules 
\textbf{loop-brk} and \textbf{seq-brk} would conflict.
%
Rule \textbf{loop-brk} escapes the enclosing loop, transforming everything into 
a $@nop$.
%Rule \textbf{loop-brk} escapes the enclosing loop, transforming everything 
%into a $clear(p)$.
%We cannot simply transform the loop into a $nop$ because its body may be a 
%parallel composition containing finalization blocks.

Proceeding to parallel compositions, the semantic rules for $and$ and $or$ 
always force transitions on their left branches $p$ to occur before their right 
branches $q$:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (p~and~q),n,\epsilon \RR \NST \LL (p~@and~(@canrun(n)~;~q)),n,\epsilon \RR
    & \textbf{(and-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~q),n,\epsilon \NST \LL (p'~@and~q),n,e \RR }
    & \textbf{(and-adv1)}      \\
%%%
& \frac
    { \DS isblocked(n,p) \1,\2 \LL q,n,\epsilon \RR \NST \LL q',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~q),n,\epsilon \RR \NST \LL (p~@and~q'), n, e \RR }
    & \textbf{(and-adv2)}      \\
%%%
& \LL (p~or~q), n, \epsilon \RR \NST \LL (p~@or~(@canrun(n)~;~q)), n, \epsilon \RR
    & \textbf{(or-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~q),n,\epsilon \RR \NST \LL (p'~@or~q), n, e \RR }
    & \textbf{(or-adv1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) \1,\2 \LL q,n,\epsilon \RR \NST \LL q',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~q),n,\epsilon \RR \NST \LL (p~@or~q'), n, e \RR }
    & \textbf{(or-adv2)}   %\\
\end{eqnarray*}
}
%
Rules \textbf{and-expd} and \textbf{or-expd} insert a $@canrun(n)$ at the
beginning of the right branch.
This ensures that an $emitInt$ on the left branch, which would transit to a
$@canrun(n)$, still resumes before the right branch starts.
%
The deterministic behavior of the semantics relies on the \emph{isblocked} 
predicate (Figure~\ref{fig.isblocked}) which appears in rules \textbf{and-adv2}
and \textbf{or-adv2}.
These rules require the left branch $p$ to be blocked in order to allow the 
right branch transition from $q$ to $q'$.

For a parallel $@and$, if one of the sides terminates, the composition is
simply substituted by the other side (rules \textbf{and-nop1} and
\textbf{and-nop2}.
%
For a parallel $or$, if one of the sides terminates, the whole composition 
terminates, also applying the $clear$ function to properly finalize the aborted 
side (rules \textbf{or-nop1} and \textbf{or-nop2}):
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (@nop~@and~q), n, \epsilon \RR \NST \LL q,n,\epsilon \RR
    & \textbf{(and-nop1)}   \\
%%%
& \LL (p~@and~@nop), n, \epsilon \RR \NST \LL p,n,\epsilon \RR
    & \textbf{(and-nop2)}   \\
%%%
& \LL (@nop~@or~q), n, \epsilon \RR \NST \LL clear(q),n,\epsilon \RR
    & \textbf{(or-nop1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~@nop), n, \epsilon \RR \NST \LL clear(p),n,\epsilon \RR }
    & \textbf{(or-nop2)}   %\\
\end{eqnarray*}
}

%
The $clear$ function (Figure~\ref{fig.formal.clear}) concatenates all active
$fin$ bodies of the side being aborted, so that they execute before the
composition rejoins.
Note that there are no transition rules for $fin$ expressions.
This is because once reached, a $fin$ expression halts and will only execute 
when it is aborted by a trail in parallel and is expanded by the $clear$ 
function.
%In Section~\ref{sec.formal.fins}, we show how to map a finalization block in 
%the concrete language to a $fin$ in the formal semantics.
%
Note also that there is a syntactic restriction that $fin$ bodies cannot
contain awaiting expressions ($awaitExt$, $awaitInt$, and $fin$), i.e., they
are guaranteed to execute entirely within a reaction.

Finally, a $break$ in one of the sides in parallel escapes the closest 
enclosing $loop$, properly aborting the other side by applying the $clear$ 
function:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (break~@and~q), n, \epsilon \RR \NST \LL (clear(q)~;~break),n,\epsilon \RR
    & \textbf{(and-brk1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~break), n, \epsilon \RR \NST \LL (clear(p)~;~break),n,\epsilon \RR }
    & \textbf{(and-brk2)}   \\
%%%
& \LL (break~@or~q),n,\epsilon \RR \NST \LL (clear(q)~;~break),n,\epsilon \RR
    & \textbf{(or-brk1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~break),n,\epsilon \RR \NST \LL (clear(p)~;~break),n,\epsilon \RR }
    & \textbf{(or-brk2)}   %\\
\end{eqnarray*}
}
%
A reaction eventually blocks in $awaitExt$, $awaitInt$, $fin$, and $@canrun$
expressions in parallel trails.
%
If no trails are blocked in $@canrun$ expressions, it means that the program 
cannot advance in the current reaction.
%
However, $@canrun$ expressions can still resume in lower stack indexes and will
eventually resume in the current reaction (see rule \textbf{pop}).

\begin{figure}
{\small
\begin{align*}
  bcast(e, awaitExt(e)) &= @nop                         \\
  bcast(e, awaitInt(e)) &= @nop                         \\
  bcast(e, @canrun(n))  &= @canrun(n)                   \\
  bcast(e, fin~p)       &= fin~p                        \\
  bcast(e, p~;~q)       &= bcast(e,p)~;~q               \\
  bcast(e, p~@loop~q)   &= bcast(e,p)~@loop~q           \\
  bcast(e, p~@and~q)    &= bcast(e,p)~@and~bcast(e,q)   \\
  bcast(e, p~@or~q)     &= bcast(e,p)~@or~bcast(e,q)    \\
  bcast(e, \_)          &= \bot \2 (mem,emitInt,break,if,  \\
                                 & \5\5 loop,and,or,@nop) %\\
\end{align*}
}
\caption{
The function $bcast$ awakes awaiting trails matching the event by converting
\code{awaitExt} and \code{awaitInt} to \code{@nop} expressions.
\label{fig.bcast}
}
\end{figure}

\begin{figure}
{\small
\begin{align*}
  isblocked(n, \1 awaitExt(id)) &= true                                   \\
  isblocked(n, \1 awaitInt(id)) &= true                                   \\
  isblocked(n, \1 @canrun(m))   &= (n > m)                                \\
  isblocked(n, \1 fin~p)        &= true                                   \\
  isblocked(n, \1 p~;~q)        &= isblocked(n,p)                         \\
  isblocked(n, \1 p~@loop~q)    &= isblocked(n,p)                         \\
  isblocked(n, \1 p~@and~q)     &= isblocked(n,p) \wedge isblocked(n,q)   \\
  isblocked(n, \1 p~@or~q)      &= isblocked(n,p) \wedge isblocked(n,q)   \\
  isblocked(n, \1 \_)           &= false \2 (mem,emitInt,break,if,        \\
                                & \5\5\5\1 loop,and,or,@nop)   %\\
\end{align*}
}
\caption{
The predicate $isblocked$ is true only if all branches in parallel are blocked
waiting for events, finalization clauses, or certain stack levels.
\label{fig.isblocked}
}
\end{figure}

\begin{figure}[b]
{\small
\begin{align*}
  clear( awaitExt(e) ) &= @nop                  \\
  clear( awaitInt(e) ) &= @nop                  \\
  clear( @canrun(n) )  &= @nop                  \\
  clear( fin~p )       &= p                     \\
  clear( p~;~q )       &= clear(p)              \\
  clear( p~@loop~q )   &= clear(p)              \\
  clear( p~@and~q )    &= clear(p)~;~clear(q)   \\
  clear( p~@or~q )     &= clear(p)~;~clear(q)   \\
  clear( \_ )          &= \bot \2 (mem,emitInt,break,if, \\
                                  & \5\5 loop,and,or,@nop) %\\ 
\end{align*}
}
\caption{
The function $clear$ extracts $fin$ expressions in parallel and put their 
bodies in sequence.
\label{fig.formal.clear}
}
\end{figure}

\subsection{Concrete Language Mapping}

Most statements from \CEU (``concrete \CEU'') map directly to those presented 
in the reduced syntax in Figure~\ref{lst.formal.syntax} (``abstract \CEU'').
%, namely, the \code{if}, \code{`;'}, \code{loop}, \code{par/and}, and 
%\code{par/or}.
For instance, the \code{if} in the concrete language behaves exactly like the 
$if$ in the formal semantics.
However, there are some significant mismatches between the concrete and 
abstract \CEU, and we (informally) present appropriate mappings in this 
section.
%
Again, we are not considering side-effects, which are all mapped to the $mem$ 
semantic construct.

\begin{comment}
$
    \code{if}      \mapsto if   ,\2
    \code{';'}     \mapsto ~';' ,\2
    \code{loop}    \mapsto loop ,\2
    \code{par/and} \mapsto and  ,\2
    \code{par/or}  \mapsto or
$.
\end{comment}

\subsubsection{await and emit}

The concrete \code{await} and \code{emit} primitives support communication of 
values between them.
In the two-step translation in Figure~\ref{lst.map.emit.await}, we start with 
the concrete program in \CEU (a), which communicates the value $1$ between the 
\code{emit} and \code{await} in parallel.
In the intermediate translation (b), we include the shared variable \code{e\_} 
to hold the value being communicated between the two trails in order to 
simplify the \code{emit}.
Finally, we convert the program into the equivalent in the abstract syntax (c), 
translating side-effect statements into $mem$ expressions.
External events have a similar translation, i.e., each external event requires 
a corresponding variable that is explicitly set by the environment before each 
reaction.

\begin{figure}[t]
\begin{minipage}[t]{0.32\linewidth}
\begin{lstlisting}
par/or do
  <...>
  emit e => 1;
with
  v = await e;
  _printf("%d\n",v);
end

.
\end{lstlisting}
\centering\small{(a)}
\end{minipage}
%
\begin{minipage}[t]{0.32\linewidth}
\begin{lstlisting}
par/or do
  <...>
  e_ = 1;
  emit e;
with
  await e;
  v = e_;
  _printf("%d\n",v);
end
\end{lstlisting}
\centering\small{(b)}
\end{minipage}
%
\begin{minipage}[t]{0.32\linewidth}
\begin{lstlisting}
<...> ; mem ; emit(e)
        or
await(e) ; mem ; mem





.
\end{lstlisting}
\centering\small{(c)}
\end{minipage}
\caption{
Two-step translation from concrete to abstract \code{emit} and \code{await} 
expressions.
The concrete code in (a) communicates the value \code{1} from the \code{emit} 
to the \code{await}.
The abstract code in (c) uses a shared variable to hold the value.
\label{lst.map.emit.await}
}
\end{figure}

\subsubsection{Finalization Blocks}
\label{sec.formal.fins}

The biggest mismatch between concrete and abstract \CEU is regarding the 
\code{finalize} blocks, which require more complex modifications in the program
for a proper mapping using $fin$ expressions.
In the three-step translation in Figure~\ref{lst.map.fin}, we start with a 
concrete program (a) that uses a \code{finalize} to safely \code{\_release} the 
reference to \code{ptr} kept after the call to \code{\_hold}.
In the translation, we first need to catch the outermost \code{do-end} 
termination to run the finalization code.
For this, we translate the block into a \code{par/or} (b) with the original 
body in parallel with a $fin$ expression to run the finalization code.
Note that the $fin$ has no transition rules in the semantics, keeping the 
\code{par/or} alive.
This way, the $fin$ body only executes when the \code{par/or} terminates either 
normally (after the \code{await B}), or aborted from an outer composition.
%
However, the $fin$ still (incorrectly) executes even if the call to 
\code{\_hold} is not reached in the body due to an abort before awaking from 
the \code{await A}.
%
To deal with this issue, for each $fin$ we need a corresponding flag to keep 
track of code that needs to be finalized (c).
%
The flag is initially set to false, avoiding the finalization code to execute.
Only after the call to \code{\_hold} that we set the flag to true and enable 
the $fin$ body to execute.
%
The complete translation substitutes the side-effect operations with $mem$ 
expressions (d).

\begin{figure}
\begin{minipage}[t]{0.26\linewidth}
\begin{lstlisting}
do
  var int* ptr = <...>;
  await A;
  finalize
    _hold(ptr);
  with
    _release(ptr);
  end
  await B;
end



.
\end{lstlisting}
\centering\small{(a)}
\end{minipage}
%
\begin{minipage}[t]{0.26\linewidth}
\begin{lstlisting}
par/or do
  var int* ptr = <...>;
  await A;
  _hold(ptr);
  await B;
with
  { fin
      _release(ptr); }
end




.
\end{lstlisting}
\centering\small{(b)}
\end{minipage}
%
\begin{minipage}[t]{0.26\linewidth}
\begin{lstlisting}
f_ = 0;
par/or do
  var int* ptr = <...>;
  await A;
  _hold(ptr);
  f_ = 1;
  await B;
with
  { fin
      if f_ then
        _release(ptr);
      end }
end
.
\end{lstlisting}
\centering\small{(c)}
\end{minipage}
%
\begin{minipage}[t]{0.18\linewidth}
\begin{lstlisting}
mem;
(
   mem;
   await(A);
   mem;
   mem;
   await(B);
or
   fin
     if mem then
       mem
     else
       nop
)
\end{lstlisting}
\centering\small{(d)}
\end{minipage}
%
\caption{
Three-step translation from concrete to abstract finalization.
\label{lst.map.fin}
}
\end{figure}
