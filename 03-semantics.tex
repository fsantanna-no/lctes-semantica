\newcommand{\NST}{\1\xrightarrow[nst]\1}
\newcommand{\OUT}{\1\xrightarrow[out]\1}
\newcommand{\LL}{\langle}
\newcommand{\RR}{\rangle}
\newcommand{\DS}{\displaystyle}

\newcommand{\1}{\;}
\newcommand{\2}{\;\;}
\newcommand{\3}{\;\;\;}
\newcommand{\5}{\;\;\;\;\;}

\section{Formal Semantics}
\label{sec.sem}

%\begin{document}

In this section, we introduce a reduced syntax of \CEU and propose an 
operational semantics to formally describe the language.
We describe a small synchronous kernel highlighting the peculiarities of \CEU, 
in particular the stack-based execution for internal events.
%
For the sake of simplicity, we focus on the control aspects of the language, 
leaving out side effects and system calls (which behave like in conventional 
imperative languages).

\subsection{Abstract Syntax}
\label{sec.sem.syntax}

\begin{lstlisting}[
  %numbers=left,
  basicstyle=\ttfamily\footnotesize,
  float=h,
  caption={Reduced syntax of \CEU.},
  label={lst.formal.syntax},
  mathescape=true
]
                                   // primary expressions
  p ::= mem(id)                    (any memory access to `id')
      $|$ awaitExt(id)               (await external event `id')
      $|$ awaitInt(id)               (await internal event `id')
      $|$ emitInt(id)                (emit internal event `id')
      $|$ break                      (loop escape)
                                   // compound expressions
      $|$ if mem(id) then p else p   (conditional)
      $|$ p ; p                      (sequence)
      $|$ loop p                     (repetition)
      $|$ every id p                 (event iteration)
      $|$ p and p                    (par/and)
      $|$ p or p                     (par/or)
      $|$ fin p                      (finalization)
                                   // derived by semantic rules
      $|$ p @loop p                  (unwinded loop)
      $|$ p @and q                   (unwinded par/and)
      $|$ p @or q                    (unwinded par/or)
      $|$ @canrun(n)                 (can run on stack level `n')
      $|$ @nop                       (terminated expression)
\end{lstlisting}

Listing~\ref{lst.formal.syntax} shows the syntax for a subset of \CEU that is 
sufficient to describe all semantic peculiarities of the language.
%
The $mem(id)$ primitive represents all accesses, assignments, system calls, and
output events that affect a memory location identified by $id$.
%
According to the synchronous hypothesis of \CEU, $mem$ expressions are 
considered to be atomic and instantaneous.
%
As the challenging parts of \CEU reside on its control structures, we are not 
concerned here with a precise semantics for side effects, but only with their 
occurrences in programs.
%
%The special notation $nop$ is used to represent an innocuous $mem$ expression 
%(it can be thought as a synonym for $mem(\epsilon)$, where $\epsilon$ is an 
%unused identifier).
%
Note that $mem$, $awaitExt$, and $awaitInt$ / $emitInt$ expressions do not
share identifiers, i.e., an identifier is either a variable, an external event,
or an internal event.

In the concrete language, the \code{await} and \code{emit} primitives support
communication of values between them, e.g., an \code{emit a(10)} awakes
\code{v=await a} setting \code{v=10}.
To reproduce this functionality in the formal semantics, we can use a shared
variable to hold the value of an \code{emit} and access it after the
corresponding \code{await}.

A ``\code{finalize <A> with <B> end ; <C>}'' in the concrete language is
equivalent to ``\code{<A> ; ((fin <B>) or <C>)}'' in the abstract syntax.
In the concrete language, \code{<A>} and \code{<C>} execute in sequence, and
the finalization code \code{<B>} is implicitly suspended waiting for \code{<C>}
termination.
In the formal language, \code{fin <B>} suspends forever when reached (it is an
awaiting expression that never awakes).
Hence, we need an explicit \code{or} to execute \code{<C>} in parallel, whose
termination aborts \code{fin <B>}, which finally causes \code{<B>} to execute
(by the semantic rules to be discussed).

\subsection{Operational Semantics}

The core of our semantics describes how a program reacts to a single external 
input event, i.e., starting from the input event, how the program behaves and 
becomes idle again to proceed to the subsequent reaction.
%
We use a set of small-step operational rules, which are built in such a way 
that at most one transition is possible at any time, resulting in deterministic 
reactions.
%
The transition rules map a triple with a program $p$, a stack level $n$, and an
emitted event $e$ to a modified triple as follows:
%
\begin{align*}
\LL p,  n,  e  \RR &\1\xrightarrow\1
\LL p', n', e' \RR
    & \textbf{(rule-general)}
\end{align*}
%
where
%
\begin{align*}
p, p' &\in P
    && (program~as~described~in~Listing~\ref{lst.formal.syntax})
\\
n, n' &\in \mathds{N}
    && (current~stack~level)
\\
e, e' &\in \mathds{E \cup \{\epsilon\}}
    && (emitted~event,~possibly~none)
\end{align*}
%
At the beginning of a reaction to an input event $id$, the triple is
initialized at stack level $0$ ($n=0$) and with the emitted event $id$
($e=id$).
%, but \code{emitInt} expressions can increase the stack level.
At the end of a reaction, after an arbitrary but finite number of transitions,
the triple will block with a (possibly) modified program $p'$, at stack level
$0$, with no event emitted $\epsilon$:
%
\begin{align*}
\LL p,0,ext \RR
    & \1\xrightarrow{*}\1
\LL p',0,\epsilon \RR
\end{align*}
%
We also distinguish between two transition rule subtypes:
    $\OUT$, for \emph{outermost} transitions; and
    $\NST$, for \emph{nested} transitions.

The $\OUT$ rules \textbf{push} and \textbf{pop} are non-recursive definitions
that only apply to the program as a whole and manipulate the stack level as
follows:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \frac
    { \DS e \neq \epsilon }
%   -----------------------------------------------------------
    { \DS \LL p,n,e \RR \OUT \LL bcast(p),n+1,\epsilon \RR }
    & \textbf{(push)}   \\
%%%
& \frac
    { \DS n>0, \2 ((p=@nop) \wedge isblocked(n,p)) }
%   -----------------------------------------------------------
    { \DS \LL p,n,\epsilon \RR \OUT \LL p,n-1,\epsilon \RR }
    & \textbf{(pop)}    \\
%%%
%& \LL p,0,\epsilon \RR \1\xrightarrow\1 \bot
    %& \textbf{(end)}    %\\
\end{eqnarray*}
}
%
Rule \textbf{push} matches whenever there is an emitted event in the triple,
and instantly broadcasts the event to the program, which means
    (a) awaking active \code{await} expressions altogether (see $bcast(p)$ in
        Figure~\ref{fig.bcast}),
    (b) creating a nested reaction by increasing the stack level,
    (c) and, at the same time, consuming the event ($e$ becomes $\epsilon$).
%
Note that rule \textbf{push} is the only one in the semantics that matches an
emitted event and also immediately consumes it.
%
The rule \textbf{pop} only decreases the stack level, not affecting the
program, and does not apply if the program is not blocked (see $isblocked(n,p)$
in Figure~\ref{fig.isblocked}).
This condition ensures that an \code{emit} only resumes after its internal
reaction completes, as discussed in Section~\ref{sec.ceu.evts}.

Note that at the beginning of a reaction, an event $ext$ is emitted, which
will trigger rule \textbf{push}, which will immediately raise the stack level
to $1$.
Since rule \textbf{pop} is the only to decrease the stack level and only
applies to a blocked or terminated program, the semantics guarantees that a
reaction only terminates with a blocked program at stack level $0$.

The $\NST$ rules are recursive definitions but do not affect the stack level
and never have an emitted event as a precondition:
%
\begin{align*}
\LL p, n,\epsilon \RR &\NST
\LL p',n,e        \RR
    & \textbf{(rule-inner)}
\end{align*}
%
The distinction between $\OUT$ and $\NST$ prevents rules \textbf{push} and
\textbf{pop} to match and inadvertently modify the current stack level before
completing a nested reaction.
%
A complete reaction behaves as follows:
%
\begin{align*}
a) &\5\5
    \LL p,0,ext \RR
        \1\xrightarrow[out]{push}\1
    \LL q,1,\epsilon \RR
\\
b) &\5\5 \1[ \1\xrightarrow[in]{*}\1
    \LL r,i,e \RR
        \1\xrightarrow[out]\1
    \LL s,j,\epsilon \RR \1]*
\\
c) &\5\5 \1\xrightarrow[in]{*}\1
    \LL t,k,\epsilon \RR
        \1\xrightarrow[out]{pop}\1
    \LL u,0,\epsilon \RR
\end{align*}
%
First (case $a$), a $\xrightarrow[out]{push}$ starts a nested reaction at level
$1$.
Then (case $b$), a series of alternations between $\NST$ transitions and a
single $\OUT$ transition represent, respectively, nested reactions and stack
operations.
Finally (case $c$), at some point, a $\xrightarrow[out]{pop}$ decrements the
stack level to $0$ and terminates the reaction.

The $\NST$ transition rules for primary expressions are as follows:
%
{ \setlength{\jot}{20pt}
\begin{align*}
\LL mem(id), n, \epsilon \RR &\NST
\LL @nop, n, \epsilon \RR
    & \textbf{(mem)}        \\
%%%
\LL emit(id), n, \epsilon \RR &\NST
\LL @canrun(n), n, id \RR
    & \textbf{(emitInt)}    \\
%%%
\LL @canrun(n), n, \epsilon \RR &\NST
\LL @nop, n, \epsilon \RR
    & \textbf{(canrun)}     \\
\end{align*}
}
%
A $mem$ operation becomes a $@nop$ which indicates termination (rule
\textbf{mem}).
An $emitInt(id)$ generates an event $id$ and transits to a $@canrun(n)$ which
can only resume at level $n$ (rule \textbf{emitInt}).
Since nested rules can only transit with $e=\epsilon$, this rule causes rule
\textbf{push} to execute at the outer level, creating a new level $n+1$ on
the stack.
Also, with the new stack level, the resulting $@canrun(n)$ itself cannot
transit, providing the desired stack-based semantics for internal events.

Proceeding to compound expressions, the rules for conditionals and sequences 
are straightforward:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \frac
    { \DS val(id) \neq 0 }
%   -----------------------------------------------------------
    { \DS \LL (if~mem(id)~then~p~else~q),n,\epsilon \RR \NST
          \LL p, n, \epsilon \RR }
    & \textbf{(if-true)}       \\
%%%
& \frac
    { \DS val(id,n) = 0 }
%   -----------------------------------------------------------
    { \DS \LL (if~mem(id)~then~p~else~q),n,\epsilon \RR \NST
          \LL q,n,\epsilon \RR }
    & \textbf{(if-false)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~;~q), n, \epsilon \RR \NST \LL (p'~;~q), n, e \RR }
    & \textbf{(seq-adv)}      \\
%%%
& \LL (@nop~;~q),n,\epsilon \RR \NST  \LL q,n,\epsilon \RR
    & \textbf{(seq-nop)}      \\
%%%
& \LL (break~;~q),n,\epsilon \RR \NST \LL break,n,\epsilon \RR
    & \textbf{(seq-brk)}
\end{eqnarray*}
}
%
Given that our semantics focuses on control, rules \textbf{if-true} and 
\textbf{if-false} are the only to query $mem$ expressions.
%
Function $val$ receives a memory identifier and returns the current memory
value.
%
%Although the value here is arbitrary, it is unique in a reaction, because a 
%given expression can execute only once within it (remember that $loops$ must 
%contain $awaits$ which, from rule \textbf{await}, cannot awake in the same 
%reaction they are reached).
%For all other rules, we omit these values (e.g., \textbf{seq-nop}).

As determined for nested rules, compound expressions also can only have
$\epsilon$ as a precondition and they never modify $n$.
However, they can still emit an event to nest another reaction.
For instance, in rule \textbf{seq-adv}, if the sub-expression $p$ emits event
$e$, the whole composition also emits $e$.
%However, rules \textbf{push} and \textbf{pop} can only match at the outermost
%level.

The rules for loops are analogous to sequences, but use \code{`@'} as 
separators to properly bind breaks to their enclosing loops:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (loop~p),n,\epsilon \RR \NST \LL (p~@loop~p), n, \epsilon \RR
    & \textbf{(loop-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
% -----------------------------------------------------------
    { \DS \LL (p~@loop~q),n,\epsilon \RR \NST \LL (p'~@loop~q), n, e \RR }
    & \textbf{(loop-adv)}    \\
%%%
& \LL (@nop~@loop~p), n, \epsilon \RR \NST \LL (loop~p), n, \epsilon \RR
    & \textbf{(loop-nop)}    \\
%%%
& \LL (break~@loop~p), n, \epsilon \RR \NST \LL @nop, n, \epsilon \RR
    & \textbf{(loop-brk)}
\end{eqnarray*}
}

%
When a program encounters a $loop$, it first expands its body in sequence with 
itself (rule \textbf{loop-expd}).
Rules \textbf{loop-adv} and \textbf{loop-nop} are similar to rules 
\textbf{seq-adv} and \textbf{seq-nop}, advancing the loop until they reach a 
$@nop$.
However, what follows the loop is the loop itself (rule \textbf{loop-nop}).
Note that if we used \code{`;'} as a separator in loops, rules 
\textbf{loop-brk} and \textbf{seq-brk} would conflict.
%
Rule \textbf{loop-brk} escapes the enclosing loop, transforming everything into 
a $@nop$.
%Rule \textbf{loop-brk} escapes the enclosing loop, transforming everything 
%into a $clear(p)$.
%We cannot simply transform the loop into a $nop$ because its body may be a 
%parallel composition containing finalization blocks.

Proceeding to parallel compositions, the semantic rules for $and$ and $or$ 
always force transitions on their left branches $p$ to occur before their right 
branches $q$:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (p~and~q),n,\epsilon \RR \NST \LL (p~@and~(@canrun(n)~;~q)),n,\epsilon \RR
    & \textbf{(and-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~q),n,\epsilon \NST \LL (p'~@and~q),n,e \RR }
    & \textbf{(and-adv1)}      \\
%%%
& \frac
    { \DS isblocked(n,p) \1,\2 \LL q,n,\epsilon \RR \NST \LL q',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~q),n,\epsilon \RR \NST \LL (p~@and~q'), n, e \RR }
    & \textbf{(and-adv2)}      \\
%%%
& \LL (p~or~q), n, \epsilon \RR \NST \LL (p~@or~(@canrun(n)~;~q)), n, \epsilon \RR
    & \textbf{(or-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~q),n,\epsilon \RR \NST \LL (p'~@or~q), n, e \RR }
    & \textbf{(or-adv1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) \1,\2 \LL q,n,\epsilon \RR \NST \LL q',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~q),n,\epsilon \RR \NST \LL (p~@or~q'), n, e \RR }
    & \textbf{(or-adv2)}   %\\
\end{eqnarray*}
}
%
Rules \textbf{and-expd} and \textbf{or-expd} insert a $@canrun(n)$ at the
beginning of the right branch.
This ensures that an $emitInt$ on the left branch, which would transit to a
$@canrun(n)$, still resumes before the right branch starts.
%
The deterministic behavior of the semantics relies on the \emph{isblocked} 
predicate (Figure~\ref{fig.isblocked}) which appears in rules \textbf{and-adv2}
and \textbf{or-adv2}.
These rules require the left branch $p$ to be blocked in order to allow the 
right branch transition from $q$ to $q'$.

For a parallel $@and$, if one of the sides terminates, the composition is
simply substituted by the other side (rules \textbf{and-nop1} and
\textbf{and-nop2}.
%
For a parallel $or$, if one of the sides terminates, the whole composition 
terminates, also applying the $clear$ function to properly finalize the aborted 
side (rules \textbf{or-nop1} and \textbf{or-nop2}):
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (@nop~@and~q), n, \epsilon \RR \NST \LL q,n,\epsilon \RR
    & \textbf{(and-nop1)}   \\
%%%
& \LL (p~@and~@nop), n, \epsilon \RR \NST \LL p,n,\epsilon \RR
    & \textbf{(and-nop2)}   \\
%%%
& \LL (@nop~@or~q), n, \epsilon \RR \NST \LL clear(q),n,\epsilon \RR
    & \textbf{(or-nop1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~@nop), n, \epsilon \RR \NST \LL clear(p),n,\epsilon \RR }
    & \textbf{(or-nop2)}   %\\
\end{eqnarray*}
}
%
The $clear$ function (Figure~\ref{fig.formal.clear}) concatenates all active
$fin$ bodies of the side being aborted, so that they execute before the
composition rejoins.
Note that there are no transition rules for $fin$ expressions.
This is because once reached, a $fin$ expression halts and will only execute 
when it is aborted by a trail in parallel and is expanded by the $clear$ 
function.
%In Section~\ref{sec.formal.fins}, we show how to map a finalization block in 
%the concrete language to a $fin$ in the formal semantics.
%
Note also that there is a syntactic restriction that $fin$ bodies cannot
contain awaiting expressions ($awaitExt$, $awaitInt$, $every$, and $fin$),
i.e., they are guaranteed to execute entirely within a reaction.

Finally, a $break$ in one of the sides in parallel escapes the closest 
enclosing $loop$, properly aborting the other side by applying the $clear$ 
function:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (break~@and~q), n, \epsilon \RR \NST \LL (clear(q)~;~break),n,\epsilon \RR
    & \textbf{(and-brk1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~break), n, \epsilon \RR \NST \LL (clear(p)~;~break),n,\epsilon \RR }
    & \textbf{(and-brk2)}   \\
%%%
& \LL (break~@or~q),n,\epsilon \RR \NST \LL (clear(q)~;~break),n,\epsilon \RR
    & \textbf{(or-brk1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~break),n,\epsilon \RR \NST \LL (clear(p)~;~break),n,\epsilon \RR }
    & \textbf{(or-brk2)}   %\\
\end{eqnarray*}
}
%
A reaction eventually blocks in $awaitExt$, $awaitInt$, $every$, $fin$, and
$@canrun$ expressions in parallel trails.
%
If no trails are blocked in $@canrun$ expressions, it means that the program 
cannot advance in the current reaction.
%
However, $@canrun$ expressions can still resume in lower stack indexes and will
eventually resume in the current reaction (see rule \textbf{pop}).

\begin{figure}
{\small
\begin{align*}
  bcast(e, awaitExt(e)) &= @nop                         \\
  bcast(e, awaitInt(e)) &= @nop                         \\
  bcast(e, every~e~p)   &= p; every e p                 \\
  bcast(e, @canrun(n))  &= @canrun(n)                   \\
  bcast(e, fin~p)       &= fin~p                        \\
  bcast(e, p~;~q)       &= bcast(e,p)~;~q               \\
  bcast(e, p~@loop~q)   &= bcast(e,p)~@loop~q           \\
  bcast(e, p~@and~q)    &= bcast(e,p)~@and~bcast(e,q)   \\
  bcast(e, p~@or~q)     &= bcast(e,p)~@or~bcast(e,q)    \\
  bcast(e, \_)          &= \bot \2 (mem,emitInt,break,if,  \\
                                 & \5\5 loop,and,or,@nop) %\\
\end{align*}
}
\caption{
The function $bcast$ awakes awaiting trails matching the event by converting
$awaitExt$ and $awaitInt$ to $@nop$ expressions, and by unwinding an $every$
expression.
\label{fig.bcast}
}
\end{figure}

\begin{figure}
{\small
\begin{align*}
  isblocked(n, \1 awaitExt(id)) &= true                                   \\
  isblocked(n, \1 awaitInt(id)) &= true                                   \\
  isblocked(n, \1 every~e~p)    &= true                                   \\
  isblocked(n, \1 @canrun(m))   &= (n > m)                                \\
  isblocked(n, \1 fin~p)        &= true                                   \\
  isblocked(n, \1 p~;~q)        &= isblocked(n,p)                         \\
  isblocked(n, \1 p~@loop~q)    &= isblocked(n,p)                         \\
  isblocked(n, \1 p~@and~q)     &= isblocked(n,p) \wedge isblocked(n,q)   \\
  isblocked(n, \1 p~@or~q)      &= isblocked(n,p) \wedge isblocked(n,q)   \\
  isblocked(n, \1 \_)           &= false \2 (mem,emitInt,break,if,        \\
                                & \5\5\5\1 loop,and,or,@nop)   %\\
\end{align*}
}
\caption{
The predicate $isblocked$ is true only if all branches in parallel are blocked
waiting for events, finalization clauses, or certain stack levels.
\label{fig.isblocked}
}
\end{figure}

\begin{figure}[b]
{\small
\begin{align*}
  clear( awaitExt(e) ) &= @nop                  \\
  clear( awaitInt(e) ) &= @nop                  \\
  clear( every~e~p )   &= @nop                  \\
  clear( @canrun(n) )  &= @nop                  \\
  clear( fin~p )       &= p                     \\
  clear( p~;~q )       &= clear(p)              \\
  clear( p~@loop~q )   &= clear(p)              \\
  clear( p~@and~q )    &= clear(p)~;~clear(q)   \\
  clear( p~@or~q )     &= clear(p)~;~clear(q)   \\
  clear( \_ )          &= \bot \2 (mem,emitInt,break,if, \\
                                  & \5\5 loop,and,or,@nop) %\\ 
\end{align*}
}
\caption{
The function $clear$ extracts $fin$ expressions in parallel and put their 
bodies in sequence.
\label{fig.formal.clear}
}
\end{figure}
