\newcommand{\NST}{\1\xrightarrow[\mathit{nst}]\1}
\newcommand{\OUT}{\1\xrightarrow[\mathit{out}]\1}
\newcommand{\LL}{\langle}
\newcommand{\RR}{\rangle}
\newcommand{\DS}{\displaystyle}

\newcommand{\1}{\;}
\newcommand{\2}{\;\;}
\newcommand{\3}{\;\;\;}
\newcommand{\5}{\;\;\;\;\;}

\section{Formal Semantics}
\label{sec.sem}

In this section, we introduce a reduced syntax for \CEU and propose an 
operational semantics to formally describe the language.
We describe a small synchronous kernel highlighting the peculiarities of \CEU, 
in particular, the stack-based execution for internal events.
%
For the sake of simplicity, we focus on the control aspects of the language, 
leaving out side-effects and system calls (which behave like in conventional 
imperative languages).

\subsection{Abstract Syntax}
\label{sec.sem.syntax}

%-
% \begin{lstlisting}[
%   %numbers=left,
%   basicstyle=\ttfamily\footnotesize,
%   float=h,
%   caption={Reduced syntax of \CEU.},
%   label={lst.formal.syntax},
%   mathescape=true
% ]
%                                    // primary expressions
%   p ::= mem(id)                    (any memory access to `id')
%       $|$ awaitExt(id)               (await external event `id')
%       $|$ awaitInt(id)               (await internal event `id')
%       $|$ emitInt(id)                (emit internal event `id')
%       $|$ break                      (loop escape)
%                                    // compound expressions
%       $|$ if mem(id) then p else p   (conditional)
%       $|$ p ; p                      (sequence)
%       $|$ loop p                     (repetition)
%       $|$ every id p                 (event iteration)
%       $|$ p and p                    (par/and)
%       $|$ p or p                     (par/or)
%       $|$ fin p                      (finalization)
%                                    // derived by semantic rules
%       $|$ p @loop p                  (unwinded loop)
%       $|$ p @and q                   (unwinded par/and)
%       $|$ p @or q                    (unwinded par/or)
%       $|$ @canrun(n)                 (can run on stack level `n')
%       $|$ @nop                       (terminated expression)
% \end{lstlisting}
%-

The grammar below defines the syntax of a subset of \CEU that is
sufficient to describe all semantic peculiarities of the language.
\bgroup
\def\lbl#1{\qquad\text{\emph{#1}}}%
\newdimen\X
\X=-1\jot
\begin{alignat*}{2}
  p\Coloneqq
      &\enspace\ceu{\Mem(\Id)}
      &&\lbl{any memory access to~``$\ceu\Id$''}\\[\X]
      %%
  \mid&\enspace\ceu{\AwaitExt(\Id)}
      &&\lbl{await external event~``$\ceu\Id$''}\\[\X]
      %%
  \mid&\enspace\ceu{\AwaitInt(\Id)}
      &&\lbl{await internal event~``$\ceu\Id$''}\\[\X]
      %%
  \mid&\enspace\ceu{\EmitInt(\Id)}
      &&\lbl{emit internal event~``$\ceu\Id$''}\\[\X]
      %%
  \mid&\enspace\ceu{\Break}
      &&\lbl{loop escape}\\[\X]
      %%
  \mid&\enspace\ceu{\Ifelse{b}{p_1}{p_2}}
      &&\lbl{conditional}\\[\X]
      %%
  \mid&\enspace\ceu{p1\,;\,p2}
      &&\lbl{sequence}\\[\X]
      %%
  \mid&\enspace\ceu{\Loop p_1}
      &&\lbl{repetition}\\[\X]
      %%
  \mid&\enspace\ceu{\Every{\Id}\ p_1}
      &&\lbl{event iteration}\\[\X]
      %%
  \mid&\enspace\ceu{p_1\And p_2}
      &&\lbl{par/and}\\[\X]
      %%
  \mid&\enspace\ceu{p_2\Or p_2}
      &&\lbl{par/or}\\[\X]
      %%
  \mid&\enspace\ceu{\Fin p}
      &&\lbl{finalization}\\[\X]
      %%
  \mid&\enspace\ceu{p_1\AtLoop p_2}
      &&\lbl{unwinded loop}\\[\X]
      %%
  \mid&\enspace\ceu{p_1\AtAnd\ p_2}
      &&\lbl{unwinded par/and}\\[\X]
      %%
  \mid&\enspace\ceu{p_1\AtOr\ p_2}
      &&\lbl{unwinded par/or}\\[\X]
      %%
  \mid&\enspace\ceu{\CanRun(n)}
      &&\lbl{can run on stack level~$n$}\\[\X]
      %%
  \mid&\enspace\ceu{\Nop}
      &&\lbl{terminated program}
\end{alignat*}
\egroup

The~$\ceu{\Mem(id)}$ primitive represents all accesses, assignments, and system calls
that affect a memory location identified by~$id$.
%
According to the synchronous hypothesis of \CEU, $\ceu{\Mem}$ expressions are 
considered to be atomic and instantaneous.
%
As the challenging parts of \CEU reside on its control structures, we are not 
concerned here with a precise semantics for side effects, but only with their 
occurrences in programs.
%
%The special notation $nop$ is used to represent an innocuous $mem$ expression 
%(it can be thought as a synonym for $mem(\epsilon)$, where $\epsilon$ is an 
%unused identifier).

We assume that $\ceu{\Mem}$, $\ceu{\AwaitExt}$, and~$\ceu{\AwaitInt}$ and~$\ceu{\EmitInt}$ expressions do not
share identifiers: any identifier is either a variable, an external event,
or an internal event.

Most expressions in the abstract language are mapped to
their counterparts in the concrete language.  The exceptions are the
finalization block~$\ceu{\Fin{p}}$ and the \texttt{@}-expressions, which are
internal expressions that result from the
expansion of awaits, emits, and loops by the transition rules to be discussed.

Regarding other mismatches between the concrete and abstract languages, the concrete
\code{await} and \code{emit} primitives support communication of values between
them, e.g., an ``\code{emit a(10)}'' awakes a ``\code{v=await a}'' setting
variable~\code{v} to~10.
To reproduce this functionality in the formal semantics, we can use a shared
variable to hold the value of an $\ceu{\EmitInt}$ and access it after the
corresponding $\ceu{\AwaitInt}$.
%
Also, a ``\code{finalize $A$ with $B$ end; $C$}'' in the concrete language is
equivalent to ``\ceu{A;\;((\Fin{B})\ \Or\ C)}'' in the abstract language.
In the concrete language, $A$ and~$C$ execute in sequence, and
the finalization code~$B$ is implicitly suspended waiting for~$C$
termination.
In the abstract language, ``$\ceu{\Fin B}$'' suspends forever when reached (it is
an awaiting expression that never awakes).
Hence, we need an explicit \code{or} to execute~$C$ in parallel, whose
termination aborts ``$\ceu{\Fin B}$'', which finally causes~$B$ to
execute (by the semantic rules to be discussed).

\subsection{Operational Semantics}

The core of our semantics describes how a program reacts to a single external 
input event, i.e., starting from an input event, how the program behaves and 
becomes idle again to proceed to a subsequent reaction.
%
We use a set of small-step operational rules, which are built in such a way 
that at most one transition is possible at any time, resulting in deterministic 
reactions.
%
The transition rules map a triple with a program~$p$, a stack level~$n$, and an
emitted event~$e$ to a modified triple as follows:
\[
  \<p,n,e>\trans\<p',n',e'>\,,
\]
where~$p,p'\in\P$ are abstract-language programs, $n,n'\in\N$ are
nonnegative integers representing the current stack level,
and~$e,e'\in\E\cup\{\nil\}$ are the events emitted before and after the
transition (both possibly the empty event~$\nil$).

We will refer to the triples on the left-hand and right-hand sides of
symbol~$\to$ as \emph{descriptions} (denoted~$\delta$).  The triple on the
left-hand side of symbol~$\to$ is called the \emph{input description}, and
the triple on its right-hand side is called the \emph{output description}.

%-
% \begin{align*}
% p, p' &\in\P
%     && (program~as~described~in~Listing~\ref{lst.formal.syntax})
% \\
% n, n' &\in\N
%     && (current~stack~level)
% \\
% e, e' &\in\E \cup \{\epsilon\}
%     && (emitted~event,~possibly~none)
% \end{align*}
%-

At the beginning of a reaction to an input event~$id$, the input description is
initialized with stack level~0 ($n=0$) and with the emitted event
($e=id$).
%, but \code{emitInt} expressions can increase the stack level.
At the end of a reaction, after an arbitrary but finite number of transitions,
the last output description will block with a (possibly) modified program~$p'$, at stack
level~0, and with no event emitted~($\nil$):
\[
  \<p,0,e>\mathbin{\trans[*]}\<p',0,\nil>\,.
\]

We distinguish between two types of transition rules:
    \emph{outermost} transitions $\out$ and
    \emph{nested} transitions $\nst$\,.

\subsubsection*{Outermost transitions}

The~$\out$ rules \R{push} and \R{pop} are non-recursive definitions
that only apply to the program as a whole and manipulate the stack level:
\begin{align*}
  &\AxiomC{$e\ne\nil$}
  \UnaryInfC{$\<p,n,e>\out\<\bcast(p,e),n+1,\nil>$}
  \DisplayProof
  \Rtag{push}\\[2\jot]
  %%
  &\AxiomC{$n>0$}
  \AxiomC{$\ceu{p=\Nop}\vee\isblocked(p,n)$}
  \BinaryInfC{$\<p,n,\nil>\out\<p,n-1,\nil>$}
  \DisplayProof
  \Rtag{pop}
\end{align*}

%-
% { \setlength{\jot}{20pt}
% \begin{eqnarray*}
% & \frac
%     { \DS e \neq \epsilon }
% %   -----------------------------------------------------------
%     { \DS \LL p,n,e \RR \OUT \LL bcast(p),n+1,\epsilon \RR }
%     & \textbf{(push)}   \\
% %%%
% & \frac
%     { \DS n>0, \2 ((p=@nop) \vee isblocked(n,p)) }
% %   -----------------------------------------------------------
%     { \DS \LL p,n,\epsilon \RR \OUT \LL p,n-1,\epsilon \RR }
%     & \textbf{(pop)}    \\
% %%%
% %& \LL p,0,\epsilon \RR \1\xrightarrow\1 \bot
%     %& \textbf{(end)}    %\\
% \end{eqnarray*}
% }
%-

Rule \R{push} matches whenever there is an emitted event in the input
description,
and instantly broadcasts the event to the program, which means
    (a)~awaking active $\ceu{\AwaitExt}$ or $\ceu{\AwaitInt}$ expressions altogether (see function~$\bcast$ in
        Figure~\ref{fig.bcast}),
    (b)~creating a nested reaction by increasing the stack level, and, at the same time, and
    (c)~consuming the event ($e$ becomes~$\nil$).
%
Rule \R{push} is the only rule in the semantics that matches an
emitted event and also immediately consumes it.

Rule \R{pop} only decreases the stack level, not affecting the
program, and only applies if the program is blocked (see function~$\isblocked$ in
Figure~\ref{fig.isblocked}).
This condition ensures that an $\ceu{\EmitInt}$ only resumes after its internal
reaction completes and blocks, as discussed in Section~\ref{sec.ceu.evts}.

At the beginning of the reaction, an external event is emitted, which
will trigger rule \textbf{push}, which will immediately raise the stack level
to~1.
At the end of the reaction, the program will block or terminate and
successive applications of
rule~\R{pop} will eventually lead to a description containing this
same program at stack level~0.
(Rule \R{pop} is the only rule that decreases the stack level.)

\subsubsection*{Nested transitions}

The~$\nst$ rules are recursive definitions with the following general
format:
\[
\<p,n,\nil>\nst\<p',n,e>.
\]
%
%-
% \begin{align*}
% \LL p, n,\epsilon \RR &\NST
% \LL p',n,e        \RR
%     & \textbf{(rule-inner)}
% \end{align*}
%-
%
Nested transitions do not affect the stack level and never have an emitted
event as a precondition.  The distinction between~$\out$ and~$\nst$ prevents
rules \R{push} and \R{pop} from matching and, consequently, from
inadvertently modifying the current stack level before the nested reaction
is complete.

A complete reaction consists of the following series of transitions:
\begin{align*}
  \<p,0,e_\ext>\out[push]\<p_1,1,\nil>
  \Big[\null\nst[*]\null\out\null\Big]\!\!\ast
  \null\nst[*]\null\out[pop]\<p',0,\nil>\,.
\end{align*}
%
%-
% \begin{align*}
% a) &\5\5
%     \LL p,0,ext \RR
%         \1\xrightarrow[out]{push}\1
%     \LL q,1,\epsilon \RR
% \\
% b) &\5\5 \1[ \1\xrightarrow[in]{*}\1
%     \LL r,i,e \RR
%         \1\xrightarrow[out]\1
%     \LL s,j,\epsilon \RR \1]*
% \\
% c) &\5\5 \1\xrightarrow[in]{*}\1
%     \LL t,k,\epsilon \RR
%         \1\xrightarrow[out]{pop}\1
%     \LL u,0,\epsilon \RR
% \end{align*}
%-
%
First, a~$\out[push]$ starts a nested reaction at level~1.
Then, a series of alternations between zero or more~$\nst$ transitions (nested reactions) and a
single~$\out$ transition (stack operation) takes place.
Finally, a last~$\out[pop]$ transition decrements the
stack level to~0 and terminates the reaction.

The~$\nst$ transition rules for atomic expressions are defined as follows:
%
{ \setlength{\jot}{20pt}
\begin{align*}
\LL mem(id), n, \epsilon \RR &\NST
\LL @nop, n, \epsilon \RR
    & \textbf{(mem)}        \\
%%%
\LL emit(id), n, \epsilon \RR &\NST
\LL @canrun(n), n, id \RR
    & \textbf{(emitInt)}    \\
%%%
\LL @canrun(n), n, \epsilon \RR &\NST
\LL @nop, n, \epsilon \RR
    & \textbf{(canrun)}     \\
\end{align*}
}
%
A $mem$ operation becomes a $@nop$ which indicates the memory access (rule
\textbf{mem}).
An $emitInt(id)$ generates an event $id$ and transits to a $@canrun(n)$ which
can only resume at level $n$ (rule \textbf{emitInt}).
Since all $\NST$ rules can only transit with $e=\epsilon$, an $emitInt$ causes
rule \textbf{push} to execute at the outer level, creating a new level $n+1$ on
the stack.
Also, with the new stack level, the resulting $@canrun(n)$ itself cannot
transit, providing the desired stack-based semantics for internal events.

Proceeding to compound expressions, the rules for conditionals and sequences 
are straightforward:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \frac
    { \DS val(id) \neq 0 }
%   -----------------------------------------------------------
    { \DS \LL (if~mem(id)~then~p~else~q),n,\epsilon \RR \NST
          \LL p, n, \epsilon \RR }
    & \textbf{(if-true)}       \\
%%%
& \frac
    { \DS val(id,n) = 0 }
%   -----------------------------------------------------------
    { \DS \LL (if~mem(id)~then~p~else~q),n,\epsilon \RR \NST
          \LL q,n,\epsilon \RR }
    & \textbf{(if-false)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~;~q), n, \epsilon \RR \NST \LL (p'~;~q), n, e \RR }
    & \textbf{(seq-adv)}      \\
%%%
& \LL (@nop~;~q),n,\epsilon \RR \NST  \LL q,n,\epsilon \RR
    & \textbf{(seq-nop)}      \\
%%%
& \LL (break~;~q),n,\epsilon \RR \NST \LL break,n,\epsilon \RR
    & \textbf{(seq-brk)}
\end{eqnarray*}
}
%
Given that our semantics focuses on control, rules \textbf{if-true} and 
\textbf{if-false} are the only to query $mem$ expressions.
%
Function $val$ receives a memory identifier and returns its current value.
%
%Although the value here is arbitrary, it is unique in a reaction, because a 
%given expression can execute only once within it (remember that $loops$ must 
%contain $awaits$ which, from rule \textbf{await}, cannot awake in the same 
%reaction they are reached).
%For all other rules, we omit these values (e.g., \textbf{seq-nop}).

%As determined for nested rules, compound expressions also can only have
%$\epsilon$ as a precondition and they never modify $n$.
%However, they can still emit an event to nest another reaction.
%For instance, in rule \textbf{seq-adv}, if the sub-expression $p$ emits event
%$e$, the whole composition also emits $e$.
%However, rules \textbf{push} and \textbf{pop} can only match at the outermost
%level.

The rules for loops are analogous to sequences, but use \code{`@'} as 
separators to properly bind breaks to their enclosing loops:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (loop~p),n,\epsilon \RR \NST \LL (p~@loop~p), n, \epsilon \RR
    & \textbf{(loop-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
% -----------------------------------------------------------
    { \DS \LL (p~@loop~q),n,\epsilon \RR \NST \LL (p'~@loop~q), n, e \RR }
    & \textbf{(loop-adv)}    \\
%%%
& \LL (@nop~@loop~p), n, \epsilon \RR \NST \LL (loop~p), n, \epsilon \RR
    & \textbf{(loop-nop)}    \\
%%%
& \LL (break~@loop~p), n, \epsilon \RR \NST \LL @nop, n, \epsilon \RR
    & \textbf{(loop-brk)}
\end{eqnarray*}
}

%
When a program encounters a $loop$, it first expands its body in sequence with 
itself (rule \textbf{loop-expd}).
Rules \textbf{loop-adv} and \textbf{loop-nop} are similar to rules 
\textbf{seq-adv} and \textbf{seq-nop}, advancing the loop until they reach a 
$@nop$.
However, what follows the loop is the loop itself (rule \textbf{loop-nop}).
Note that if we used \code{`;'} as a separator in loops, rules 
\textbf{loop-brk} and \textbf{seq-brk} would conflict.
%
Rule \textbf{loop-brk} escapes the enclosing loop, transforming everything into 
a $@nop$.
%Rule \textbf{loop-brk} escapes the enclosing loop, transforming everything 
%into a $clear(p)$.
%We cannot simply transform the loop into a $nop$ because its body may be a 
%parallel composition containing finalization blocks.

Proceeding to parallel compositions, the semantic rules for $and$ and $or$ 
always force transitions on their left branches $p$ to occur before their right 
branches $q$:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (p~and~q),n,\epsilon \RR \NST \LL (p~@and~(@canrun(n)~;~q)),n,\epsilon \RR
    & \textbf{(and-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~q),n,\epsilon \NST \LL (p'~@and~q),n,e \RR }
    & \textbf{(and-adv1)}      \\
%%%
& \frac
    { \DS isblocked(n,p) \1,\2 \LL q,n,\epsilon \RR \NST \LL q',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~q),n,\epsilon \RR \NST \LL (p~@and~q'), n, e \RR }
    & \textbf{(and-adv2)}      \\
%%%
& \LL (p~or~q), n, \epsilon \RR \NST \LL (p~@or~(@canrun(n)~;~q)), n, \epsilon \RR
    & \textbf{(or-expd)}       \\
%%%
& \frac
    { \DS \LL p,n,\epsilon \RR \NST \LL p',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~q),n,\epsilon \RR \NST \LL (p'~@or~q), n, e \RR }
    & \textbf{(or-adv1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) \1,\2 \LL q,n,\epsilon \RR \NST \LL q',n,e \RR }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~q),n,\epsilon \RR \NST \LL (p~@or~q'), n, e \RR }
    & \textbf{(or-adv2)}   %\\
\end{eqnarray*}
}
%
Rules \textbf{and-expd} and \textbf{or-expd} insert a $@canrun(n)$ at the
beginning of the right branch.
This ensures that an $emitInt$ on the left branch, which transits to a
$@canrun(n)$, still resumes before the right branch starts.
%
The deterministic behavior of the semantics relies on the \emph{isblocked} 
predicate (see Figure~\ref{fig.isblocked}) which appears in rules
\textbf{and-adv2} and \textbf{or-adv2}.
These rules require the left branch $p$ to be blocked in order to allow the 
right branch transition from $q$ to $q'$.

For a parallel $@and$, if one of the sides terminates, the composition is
simply substituted by the other side (rules \textbf{and-nop1} and
\textbf{and-nop2}.
%
For a parallel $or$, if one of the sides terminates, the whole composition 
terminates, also applying the $clear$ function to properly finalize the aborted 
side (rules \textbf{or-nop1} and \textbf{or-nop2}):
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (@nop~@and~q), n, \epsilon \RR \NST \LL q,n,\epsilon \RR
    & \textbf{(and-nop1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~@nop), n, \epsilon \RR \NST \LL p,n,\epsilon \RR }
    & \textbf{(and-nop2)}   \\
%%%
& \LL (@nop~@or~q), n, \epsilon \RR \NST \LL clear(q),n,\epsilon \RR
    & \textbf{(or-nop1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~@nop), n, \epsilon \RR \NST \LL clear(p),n,\epsilon \RR }
    & \textbf{(or-nop2)}   %\\
\end{eqnarray*}
}
%
The $clear$ function (see Figure~\ref{fig.formal.clear}) concatenates all
active $fin$ bodies of the side being aborted, so that they execute before the
composition rejoins.
Note that there are no transition rules for $fin$ expressions.
This is because once reached, a $fin$ expression halts and will only execute 
when it is aborted by a trail in parallel and is expanded by the $clear$ 
function.
%In Section~\ref{sec.formal.fins}, we show how to map a finalization block in 
%the concrete language to a $fin$ in the formal semantics.
%
Note also that there is a syntactic restriction that $fin$ bodies cannot
contain awaiting expressions ($awaitExt$, $awaitInt$, $every$, and $fin$),
i.e., they are guaranteed to execute entirely within a reaction.

Finally, a $break$ in one of the sides in parallel escapes the closest 
enclosing $loop$, properly aborting the other side by applying the $clear$ 
function:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL (break~@and~q), n, \epsilon \RR \NST \LL (clear(q)~;~break),n,\epsilon \RR
    & \textbf{(and-brk1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@and~break), n, \epsilon \RR \NST \LL (clear(p)~;~break),n,\epsilon \RR }
    & \textbf{(and-brk2)}   \\
%%%
& \LL (break~@or~q),n,\epsilon \RR \NST \LL (clear(q)~;~break),n,\epsilon \RR
    & \textbf{(or-brk1)}   \\
%%%
& \frac
    { \DS isblocked(n,p) }
%   -----------------------------------------------------------
    { \DS \LL (p~@or~break),n,\epsilon \RR \NST \LL (clear(p)~;~break),n,\epsilon \RR }
    & \textbf{(or-brk2)}   %\\
\end{eqnarray*}
}
%
A reaction eventually blocks in $awaitExt$, $awaitInt$, $every$, $fin$, and
$@canrun$ expressions in parallel trails.
%
If no trails are blocked in $@canrun$ expressions, it means that the program 
cannot advance in the current reaction.
%
However, $@canrun$ expressions can still resume in lower stack indexes and will
eventually resume in the current reaction (see rule \textbf{pop}).

\begin{figure}
{\small
\begin{align*}
  bcast(e, awaitExt(e)) &= @nop                         \\
  bcast(e, awaitInt(e)) &= @nop                         \\
  bcast(e, every~e~p)   &= p;~every~e~p                 \\
  bcast(e, @canrun(n))  &= @canrun(n)                   \\
  bcast(e, fin~p)       &= fin~p                        \\
  bcast(e, p~;~q)       &= bcast(e,p)~;~q               \\
  bcast(e, p~@loop~q)   &= bcast(e,p)~@loop~q           \\
  bcast(e, p~@and~q)    &= bcast(e,p)~@and~bcast(e,q)   \\
  bcast(e, p~@or~q)     &= bcast(e,p)~@or~bcast(e,q)    \\
  bcast(e, \_)          &= \bot \2 (mem,emitInt,break,if,  \\
                                 & \5\5 loop,and,or,@nop) %\\
\end{align*}
}
\caption{
The function $bcast$ awakes awaiting trails matching the event by converting
$awaitExt$ and $awaitInt$ to $@nop$ expressions, and by unwinding $every$
expressions.
\label{fig.bcast}
}
\end{figure}

\begin{figure}
{\small
\begin{align*}
  isblocked(n, \1 awaitExt(id)) &= true                                   \\
  isblocked(n, \1 awaitInt(id)) &= true                                   \\
  isblocked(n, \1 every~e~p)    &= true                                   \\
  isblocked(n, \1 @canrun(m))   &= (n > m)                                \\
  isblocked(n, \1 fin~p)        &= true                                   \\
  isblocked(n, \1 p~;~q)        &= isblocked(n,p)                         \\
  isblocked(n, \1 p~@loop~q)    &= isblocked(n,p)                         \\
  isblocked(n, \1 p~@and~q)     &= isblocked(n,p) \wedge isblocked(n,q)   \\
  isblocked(n, \1 p~@or~q)      &= isblocked(n,p) \wedge isblocked(n,q)   \\
  isblocked(n, \1 \_)           &= false \2 (mem,emitInt,break,if,        \\
                                & \5\5\5\1 loop,and,or,@nop)   %\\
\end{align*}
}
\caption{
The predicate $isblocked$ is true only if all branches in parallel are blocked
waiting for events, finalization clauses, or certain stack levels.
\label{fig.isblocked}
}
\end{figure}

\begin{figure}[b]
{\small
\begin{align*}
  clear( awaitExt(e) ) &= @nop                  \\
  clear( awaitInt(e) ) &= @nop                  \\
  clear( every~e~p )   &= @nop                  \\
  clear( @canrun(n) )  &= @nop                  \\
  clear( fin~p )       &= p                     \\
  clear( p~;~q )       &= clear(p)              \\
  clear( p~@loop~q )   &= clear(p)              \\
  clear( p~@and~q )    &= clear(p)~;~clear(q)   \\
  clear( p~@or~q )     &= clear(p)~;~clear(q)   \\
  clear( \_ )          &= \bot \2 (mem,emitInt,break,if, \\
                                  & \5\5 loop,and,or,@nop) %\\ 
\end{align*}
}
\caption{
The function $clear$ extracts $fin$ expressions in parallel and put their 
bodies in sequence.
\label{fig.formal.clear}
}
\end{figure}

\subsection{Determinism, Termination, and Memory Bounds}

- informal discussion

\subsubsection*{Determinism}

The proof for determinism relies on the fact all semantic rules are mutually
exclusive, i.e., their preconditions are unique in the set of rules.
This can be verified by direct inspection of rules.

Rule \textbf{push} is the only one with $e \neq \epsilon$ as a precondition,
and is trivially mutually exclusive with all other rules.

Rule \textbf{pop} either has $p=@nop$ or $isblocked(n,p)$ as preconditions.
%
Note that rule \textbf{pop} only applies syntactically to top-level
transitions.
For instance, it can never match $\NST$ rules for subprograms as in rule
\textbf{seq-adv}.
%
Hence, for the first case, rule \textbf{pop} only applies, and is the only one
to apply, to $nop$ as the whole program (i.e., a $nop$ not surrounded by other
expressions, such as in rule \textbf{seq-nop}).
%
For the second case, we need to show that given $\LL p,n,\epsilon \RR$, no
$\NST$ transitions apply with $isblocked(n,p)$ and vice versa.
Except for $@canrun$, there are no $\NST$ transitions for the other blocking
expressions ($awaitExt$, $awaitInt$, $every$, and $fin$).
However, considering the precondition $\LL p,n,\epsilon \RR$,
$isblocked(n,@canrun(n))$ is false.
Hence, given the preconditions for rule \textbf{pop}, no $\NST$ transitions can
occur.
Conversely, if a $\NST$ transition is possible, then $isblocked(n,p)$ must be
false.
Again, except for $@canrun$, all other transitions do not involve blocking
expressions, hence, for these transitions, $isblocked(n,p)$ must be false.
For rule \textbf{canrun}, a transition can only occur if the current stack
level matches $@canrun(n)$.
In this case, $isblocked(n,@canrun(n))$ is false.

Finally, we need to show that $\NST$ transitions are mutually exclusive among
themselves.
%
Note that most rules have unique syntactic prefixes, e.g., $(@nop~@and~q)$
(rule \textbf{and-nop1}) is trivially mutually exclusive with $(@nop~@loop~p)$
(rule \textbf{or-nop1}).
%
The only exceptions are rules \textbf{and-adv1} vs. \textbf{and-adv2}, and
\textbf{or-adv1} vs. \textbf{or-adv2}.
In both cases, we need to show that if the left branch can advance, then it
cannot be blocked and vice-versa, i.e., that 
$\LL p,n,\epsilon \RR \NST \LL p',n,e \RR$ and $isblocked(n,p)$ are mutually
exclusive, which is exactly the same reasoning for rule \textbf{pop} above.

\subsubsection*{Termination}

- there is always a possible transition until n=0

every cannot restart itself
    - break disallowed
    - emit ignored

\subsubsection*{Memory Bounds}

- program is finite
- lexical scope
    - no heap allocation
- no code reentrancy
    - reexecution only due to loops
    - loop reuse nested vars
- 
