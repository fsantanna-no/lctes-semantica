\newcommand{\ST}{\1\xrightarrow[~n~]{}\1}
\newcommand{\LL}{\langle}
\newcommand{\RR}{\rangle}
\newcommand{\DS}{\displaystyle}

\newcommand{\1}{\;}
\newcommand{\2}{\;\;}
\newcommand{\3}{\;\;\;}
\newcommand{\5}{\;\;\;\;\;}

\section{Formal Semantics}
\label{sec.sem}

%\begin{document}

In this section, we introduce a reduced syntax of \CEU and propose an 
operational semantics to formally describe the language.
We describe a small synchronous kernel highlighting the peculiarities of \CEU, 
in particular the stack-based execution for internal events.
%
For the sake of simplicity, we focus on the control aspects of the language, 
leaving out side effects and system calls (which behave like in conventional 
imperative languages).

\subsection{Abstract Syntax}
\label{sec.sem.syntax}

\begin{figure}
\begin{lstlisting}[mathescape=true]
                                   // primary expressions
  p ::= mem(id)                   (any memory access to `id')
      $|$ await(id)                  (await event `id')
      $|$ emit(id)                   (emit event `id')
      $|$ break                      (loop escape)
                                   // compound expressions
      $|$ if mem(id) then p else p   (conditional)
      $|$ p ; p                      (sequence)
      $|$ loop p                     (repetition)
      $|$ p and p                    (par/and)
      $|$ p or p                     (par/or)
      $|$ fin p                      (finalization)
                                   // derived by semantic rules
      $|$ awaiting(id,n)             (awaiting `id' since sequence number `n')
      $|$ emitting(n)                (emitting on stack level `n')
      $|$ p @ loop p                 (unwinded loop)
      $|$ nop                        (terminated expression)
\end{lstlisting}
\caption{
    Reduced syntax of \CEU.
\label{lst.formal.syntax}
}
\end{figure}

Figure~\ref{lst.formal.syntax} shows the syntax for a subset of \CEU that is 
sufficient to describe all semantic peculiarities of the language.
%
Except for $fin$ and the expressions used internally by the semantics (i.e., 
$awating$, $emitting$, $p~@~loop; p$, and $nop$), all other expressions are 
equivalent to their counterparts in the concrete language.

The $mem(id)$ primitive represents all accesses, assignments, system calls, and 
output events that affect a memory location identified by $id$.
%
According to the synchronous hypothesis of \CEU, $mem$ expressions are 
considered to be atomic and instantaneous.
%
As the challenging parts of \CEU reside on its control structures, we are not 
concerned here with a precise semantics for side effects, but only with their 
occurrences in programs.
%
%The special notation $nop$ is used to represent an innocuous $mem$ expression 
%(it can be thought as a synonym for $mem(\epsilon)$, where $\epsilon$ is an 
%unused identifier).
%
Note that $mem$ and $await$/$emit$ expressions do not share identifiers, i.e., 
an identifier is either a variable or an event.

\subsection{Operational Semantics}

The core of our semantics describes how a program reacts to a single external 
input event, i.e., starting from the input event, how the program behaves and 
becomes idle again to proceed to the subsequent reaction.
%
We use a set of small-step operational rules, which are built in such a way 
that at most one transition is possible at any time, resulting in deterministic 
reactions.
%
Each reaction is identified by a ever-increasing $n$ that remains constant 
during the entire reaction.
The transition rules map a program $p$ and a stack of events $S$ in a single 
step to a modified program and stack:
%
\begin{align*}
\LL S, p \RR &\ST
\LL S', p' \RR
    & \textbf{(rule-inner)}
\end{align*}
%
where
%
\begin{align*}
S, S' &\in id^*
    &&(stack~of~event~identifiers: [id_{top}, ..., id_{bottom}]) \\
p, p' &\in P
    && (program~as~described~in~Figure~\ref{lst.formal.syntax}) \\
n     &\in \mathds{N}
    && (unique~identifier~for~the~entire~reaction)
\end{align*}
%
At the beginning of a reaction, the stack is initialized with the occurring 
external event $ext$ ($S=[ext]$), but $emit$ expressions can push new events on 
top of it (we discuss how they are popped further).
The sequence number $n$, which is incremented each reaction, prevents that 
awaiting expressions awake in the same reaction they are reached (the 
\emph{delayed awaits} as explained in Section~\ref{sec.ceu.ints}).

The transition rules for the primary expressions are as follows:
%
{ \setlength{\jot}{20pt}
\begin{align*}
\LL S,\1mem(id) \RR &\ST
\LL S,\1nop \RR
    & \textbf{(mem)}        \\
%%%
\LL S,\1await(id) \RR &\ST
\LL S,\1awaiting(id,n+1) \RR
    & \textbf{(await)}      \\
%%%
\LL id:S,\1awaiting(id,m) \RR &\ST
\LL id:S,\1nop \RR, \2if~m\leq n
    & \textbf{(awake)}   \\
%%%
\LL S,\1emit(id) \RR &\ST
\LL id:S,\1emitting(|S|) \RR
    & \textbf{(emit)}       \\
%%%
\LL S,\1emitting(k) \RR &\ST
\LL S,\1nop \RR, \2 if~k=|S|
    & \textbf{(pop)}        %\\
\end{align*}
}
%
A $mem$ operation executes immediately and becomes a $nop$ to indicate 
termination (rule \textbf{mem}).
An $await$ is transformed into an $awaiting$ (rule \textbf{await}) as an 
artifice to remember the external sequence number $n+1$ it can awake:
an $awaiting$ can only transit to a $nop$ (rule \textbf{awake}) if its referred 
event $id$ matches the top of the stack and it was reached in a previous 
reaction (i.e., sequence number $m \leq n$).
%
%Remember that in \CEU, the \code{await} statement returns the value associated 
%with the corresponding event: the yielded $mem$ represents the operation to 
%query that value.
%
An $emit$ transits to an $emitting$ holding the current stack level ($|S|$ 
stands for the stack length), and pushing the referred event on the stack (rule 
\textbf{emit}).
With the new stack level $|S|+1$, the $emitting(|S|)$ itself cannot transit, as 
rule \textbf{pop} expects its parameter $k$ to match the current stack level.
This trick provides the desired stack-based semantics for internal events.

Proceeding to compound expressions, the rules for conditionals and sequences 
are straightforward:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \frac
    { \DS val(id,n) \neq 0 }
%   -----------------------------------------------------------
    { \DS \LL S, (if~mem(id)~then~p~else~q) \RR \ST
          \LL S, p \RR }
    & \textbf{(if-true)}       \\
%%%
& \frac
    { \DS val(id,n) = 0 }
%   -----------------------------------------------------------
    { \DS \LL S, (if~mem(id)~then~p~else~q) \RR \ST
          \LL S, q \RR }
    & \textbf{(if-false)}       \\
%%%
& \frac
    {\DS \LL S,p \RR \ST \LL S',p' \RR }
%   -----------------------------------------------------------
    {\DS \LL S, (p~;~q) \RR \ST \LL S', (p'~;~q) \RR }
    & \textbf{(seq-adv)}      \\
%%%
& \LL S, (nop~;~q) \RR \ST  \LL S, q \RR
    & \textbf{(seq-nop)}      \\
%%%
& \LL S, (break~;~q) \RR \ST \LL S, break \RR
    & \textbf{(seq-brk)}
\end{eqnarray*}
}
%
Given that our semantics focuses on control, rules \textbf{if-true} and 
\textbf{if-false} are the only to query $mem$ expressions.
%
The ``magical'' function $val$ receives a memory identifier and the current 
reaction sequence number, returning the current memory value.
%
Although the value here is arbitrary, it is unique in a reaction, because a 
given expression can execute only once within it (remember that $loops$ must 
contain $awaits$ which, from rule \textbf{await}, cannot awake in the same 
reaction they are reached).
%For all other rules, we omit these values (e.g., \textbf{seq-nop}).

The rules for loops are analogous to sequences, but use \code{`@'} as 
separators to properly bind breaks to their enclosing loops:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL S, (loop~p) \RR \ST \LL S, (p~@~loop~p) \RR
    & \textbf{(loop-expd)}       \\
%%%
& \frac
    {\DS \LL S,p \RR \ST \LL S',p' \RR }
% -----------------------------------------------------------
    {\DS \LL S, (p~@~loop~q) \RR \ST \LL S', (p'~@~loop~q) \RR }
    & \textbf{(loop-adv)}    \\
%%%
& \LL S, (nop~@~loop~p) \RR \ST \LL S, loop~p \RR
    & \textbf{(loop-nop)}    \\
%%%
& \LL S, (break~@~loop~p) \RR \ST \LL S, nop \RR
    & \textbf{(loop-brk)}
\end{eqnarray*}
}
%
When a program encounters a $loop$, it first expands its body in sequence with 
itself (rule \textbf{loop-expd}).
Rules \textbf{loop-adv} and \textbf{loop-nop} are similar to rules 
\textbf{seq-adv} and \textbf{seq-nop}, advancing the loop until they reach a 
$nop$.
However, what follows the loop is the loop itself (rule \textbf{loop-nop}).
Note that if we used \code{`;'} as a separator in loops, rules 
\textbf{loop-brk} and \textbf{seq-brk} would conflict.
%
Rule \textbf{loop-brk} escapes the enclosing loop, transforming everything into 
a $nop$.
%Rule \textbf{loop-brk} escapes the enclosing loop, transforming everything 
%into a $clear(p)$.
%We cannot simply transform the loop into a $nop$ because its body may be a 
%parallel composition containing finalization blocks.

Proceeding to parallel compositions, the semantic rules for $and$ and $or$ 
always force transitions on their left branches $p$ to occur before their right 
branches $q$:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \frac
    {\DS \LL S,p \RR \ST \LL S',p' \RR }
%   -----------------------------------------------------------
    {\DS \LL S, (p~and~q) \RR \ST \LL S', (p'~and~q) \RR }
    & \textbf{(and-adv1)}      \\
%%%
& \frac
    {\DS isBlocked(n,S,p) \1,\2 \LL S,q \RR \ST \LL S',q' \RR }
%   -----------------------------------------------------------
    {\DS \LL S, (p~and~q) \RR \ST \LL S', (p~and~q') \RR }
    & \textbf{(and-adv2)}      \\
%%%
& \frac
    {\DS \LL S,p \RR \ST \LL S',p' \RR }
%   -----------------------------------------------------------
    {\DS \LL S, (p~or~q) \RR \ST \LL S', (p'~or~q) \RR }
    & \textbf{(or-adv1)}   \\
%%%
& \frac
    {\DS isBlocked(n,S,p) \1,\2 \LL S,q \RR \ST \LL S',q' \RR }
%   -----------------------------------------------------------
    {\DS \LL S (p~or~q) \RR \ST \LL S', (p~or~q') \RR }
    & \textbf{(or-adv2)}   %\\
\end{eqnarray*}
}
%
The deterministic behavior of the semantics relies on the \emph{isBlocked} 
predicate, which is defined in Figure~\ref{fig.isBlocked} and used in rules 
\textbf{and-adv2} and \textbf{or-adv2}.
These rules require the left branch $p$ to be blocked in order to allow the 
right transition from $q$ to $q'$.
%
Basically, the \emph{isBlocked} predicate determines that an expression becomes 
blocked when all of its trails in parallel hang in $awaiting$ and $emitting$ 
expressions that cannot advance.

\begin{figure}
{\small
\begin{align*}
  isBlocked(n,a:S, awaiting(b,m)) &= (a \neq b \1\vee\1 m > n)   \\
  isBlocked(n,S, emitting(s))    &= (|S| \neq s)                     \\
  isBlocked(n,S, (p~;~q))        &= isBlocked(n,S,p)             \\
  isBlocked(n,S, (p~@~loop~q))   &= isBlocked(n,S,p)             \\
  isBlocked(n,S, (p~and~q))      &= isBlocked(n,S,p) \wedge
                                    isBlocked(n,S,q)             \\
  isBlocked(n,S, (p~or~q))       &= isBlocked(n,S,p) \wedge
                                    isBlocked(n,S,q)             \\
  isBlocked(n,S, \_)             &= false \2  (nop,await,      \\
                                  &    \5\5\5\2 emit,break,if,loop)   %\\
\end{align*}
}%
%\rule{14cm}{0.37pt}
\caption{
The recursive predicate $isBlocked$ is true only if all branches in parallel 
are hanged in $awaiting$ or $emitting$ expressions that cannot transit.
\label{fig.isBlocked}
}
\end{figure}

%%%

For a parallel $and$, if one of the sides terminates, the composition is simply 
substituted by the other side (rules \textbf{and-nop1} and \textbf{and-nop2}, 
as follows).
%
For a parallel $or$, if one of the sides terminates, the whole composition 
terminates, also applying the $clear$ function to properly finalize the aborted 
side (rules \textbf{or-nop1} and \textbf{or-nop2}):
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL S, (nop~and~q) \RR \ST \LL S, q \RR
    & \textbf{(and-nop1)}   \\
%%%
& \LL S, (p~and~nop) \RR \ST \LL S, p \RR
    & \textbf{(and-nop2)}   \\
%%%
& \LL S, (nop~or~q) \RR \ST \LL S, clear(q) \RR
    & \textbf{(or-nop1)}   \\
%%%
& \frac
    {\DS isBlocked(n,S,p) }
%   -----------------------------------------------------------
    {\DS \LL S, (p~or~nop) \RR \ST \LL S, clear(p) \RR }
    & \textbf{(or-nop2)}   %\\
\end{eqnarray*}
}
%
The $clear$ function, defined in Figure~\ref{fig.formal.clear}, concatenates 
all active $fin$ bodies of the side being aborted, so that they execute before 
the composition rejoins.
Note that there are no transition rules for $fin$ expressions.
This is because once reached, a $fin$ expression halts and will only execute 
when it is aborted by a trail in parallel and is expanded by the $clear$ 
function.
In Section~\ref{sec.formal.fins}, we show how to map a finalization block in 
the concrete language to a $fin$ in the formal semantics.
%
Note also that there is a syntactic restriction that a $fin$ body can only 
contain $mem$ expressions in sequence, i.e., they are guaranteed to execute 
entirely within a reaction.

\begin{figure}[b]
{\small
\begin{align*}
  clear( fin~p )       &= p                   \\
  clear( p~;~q )       &= clear(p)            \\
  clear( p~@~loop~q) ) &= clear(p)            \\
  clear( p~and~q )     &= clear(p)~;~clear(q) \\
  clear( p~or~q )      &= clear(p)~;~clear(q) \\
  clear( \_ )          &= nop
\end{align*}
}%
%\rule{14cm}{0.37pt}
\caption{
The function $clear$ extracts $fin$ expressions in parallel and put their 
bodies in sequence.
\label{fig.formal.clear}
}
\end{figure}

Finally, a $break$ in one of the sides in parallel escapes the closest 
enclosing $loop$, properly aborting the other side by applying the $clear$ 
function:
%
{ \setlength{\jot}{20pt}
\begin{eqnarray*}
& \LL S, (break~and~q) \RR \ST \LL S, (clear(q)~;~break) \RR
    & \textbf{(and-brk1)}   \\
%%%
& \frac
    {\DS isBlocked(n,S,p) }
%   -----------------------------------------------------------
    {\DS \LL S, (p~and~break) \RR \ST \LL S, (clear(p)~;~break) \RR }
    & \textbf{(and-brk2)}   \\
%%%
& \LL S, (break~or~q) \ST \LL S, (clear(q)~;~break) \RR
    & \textbf{(or-brk1)}   \\
%%%
& \frac
    {\DS isBlocked(n,S,p) }
%   -----------------------------------------------------------
    {\DS \LL S, (p~or~break) \RR \ST \LL S, (clear(p)~;~break) \RR }
    & \textbf{(or-brk2)}   %\\
\end{eqnarray*}
}
%
A reaction eventually blocks in $awaiting$ and $emitting$ expressions in 
parallel trails.
%
If all trails hangs only in $awaiting$ expressions, it means that the program 
cannot advance in the current reaction.
%
However, $emitting$ expressions are pending in lower stack indexes and should 
eventually resume in the ongoing reaction (see rule \textbf{pop}).
%
Therefore, we define another rule that behaves as \textbf{rule-inner} 
(presented above) if the program can advance, and, otherwise, pops the stack to 
resume the lower level:
%
$$
\frac
    { \DS \LL S,p \RR \ST                   \LL S',p' \RR }
%   -----------------------------------------------------------
    {     \LL S,p \RR \xRightarrow[~~n~~]{} \LL S',p' \RR }
%
\5\5\5
%
\frac
    { \DS isBlocked(n,\1s:S,\1p) }
%   -----------------------------------------------------------
    { \LL s:S,p \RR \xRightarrow[~~n~~]{} \LL S,p \RR }
\5\5\5\textbf{(rule-outer)}
$$
%
To describe a \emph{reaction} in \CEU, i.e., how a program behaves in reaction 
to a single external event, we use the reflexive transitive closure of 
\textbf{rule-outer}:
%
$$
    \LL S,p \RR \xRightarrow[~~n~~]{*} \LL S',p' \RR
$$
%
Finally, to describe the complete execution of a program, we trigger multiple 
``invocations'' of reactions in sequence:
%
\begin{align*}
\LL [e1], p \RR
    & \xRightarrow[~~1~~]{*}
\LL [  ], p' \RR
\\
\LL [e2], p' \RR
    & \xRightarrow[~~2~~]{*}
\LL [  ], p'' \RR
\\
\LL [e3], p'' \RR
    & \xRightarrow[~~3~~]{*}
\LL [  ], p''' \RR
\\
& ...
\end{align*}
%
Each invocation starts with the occurring external event at the top of the 
stack and finishes with a modified program and an empty stack.
After each invocation, we increment the sequence number.

\subsection{Concrete Language Mapping}

Most statements from \CEU (``concrete \CEU'') map directly to those presented 
in the reduced syntax in Figure~\ref{lst.formal.syntax} (``abstract \CEU'').
%, namely, the \code{if}, \code{`;'}, \code{loop}, \code{par/and}, and 
%\code{par/or}.
For instance, the \code{if} in the concrete language behaves exactly like the 
$if$ in the formal semantics.
However, there are some significant mismatches between the concrete and 
abstract \CEU, and we (informally) present appropriate mappings in this 
section.
%
Again, we are not considering side-effects, which are all mapped to the $mem$ 
semantic construct.

\begin{comment}
$
    \code{if}      \mapsto if   ,\2
    \code{';'}     \mapsto ~';' ,\2
    \code{loop}    \mapsto loop ,\2
    \code{par/and} \mapsto and  ,\2
    \code{par/or}  \mapsto or
$.
\end{comment}

\subsubsection{await and emit}

The concrete \code{await} and \code{emit} primitives support communication of 
values between them.
In the two-step translation in Figure~\ref{lst.map.emit.await}, we start with 
the concrete program in \CEU (a), which communicates the value $1$ between the 
\code{emit} and \code{await} in parallel.
In the intermediate translation (b), we include the shared variable \code{e\_} 
to hold the value being communicated between the two trails in order to 
simplify the \code{emit}.
Finally, we convert the program into the equivalent in the abstract syntax (c), 
translating side-effect statements into $mem$ expressions.
External events have a similar translation, i.e., each external event requires 
a corresponding variable that is explicitly set by the environment before each 
reaction.

\begin{figure}[t]
\begin{minipage}[t]{0.32\linewidth}
\begin{lstlisting}
par/or do
  <...>
  emit e => 1;
with
  v = await e;
  _printf("%d\n",v);
end

.
\end{lstlisting}
\centering\small{(a)}
\end{minipage}
%
\begin{minipage}[t]{0.32\linewidth}
\begin{lstlisting}
par/or do
  <...>
  e_ = 1;
  emit e;
with
  await e;
  v = e_;
  _printf("%d\n",v);
end
\end{lstlisting}
\centering\small{(b)}
\end{minipage}
%
\begin{minipage}[t]{0.32\linewidth}
\begin{lstlisting}
<...> ; mem ; emit(e)
        or
await(e) ; mem ; mem





.
\end{lstlisting}
\centering\small{(c)}
\end{minipage}
\caption{
Two-step translation from concrete to abstract \code{emit} and \code{await} 
expressions.
The concrete code in (a) communicates the value \code{1} from the \code{emit} 
to the \code{await}.
The abstract code in (c) uses a shared variable to hold the value.
\label{lst.map.emit.await}
}
\end{figure}

\subsubsection{First-class Timers}

To encompass first-class timers, we introduce a special external event 
\code{DT} that is intercalated with each other event occurrence in an 
application (e.g.  \emph{e1, e2}):

\begin{align*}
\LL [DT], p \RR
    & \xRightarrow[~~1~~]{*}
\LL [    ], p' \RR
\\
\LL [e1], p' \RR
    & \xRightarrow[~~2~~]{*}
\LL [  ], p'' \RR
\\
\LL [DT], p'' \RR
    & \xRightarrow[~~3~~]{*}
\LL [    ], p''' \RR
\\
\LL [e2], p''' \RR
    & \xRightarrow[~~4~~]{*}
\LL [  ], p'''' \RR
\\
& ...
\end{align*}

The event \code{DT} has an associated variable \code{DT\_} carrying the 
wall-clock time elapsed between two occurrences in sequence, as depicted by the 
two-step translation in Figure~\ref{lst.map.timers.2}.
In the concrete program (a), the variable \code{dt} holds the residual delta 
time (as described in Section~\ref{sec.ceu.timers}) after awaking from the 
timer.
In the first step of the translation (b), we expand the \code{await 10ms} to a 
\code{loop} that decrements the elapsed number of microseconds for each 
occurrence of \code{DT}.
When the variable \code{tot} reaches zero, we escape the \code{loop} setting 
the variable \code{dt} to contain the appropriate delta.
In the last step (c), we convert the program to the abstract syntax.

\begin{figure}
\begin{minipage}[t]{0.30\linewidth}
\begin{lstlisting}
dt = await 10ms;








.
\end{lstlisting}
\centering\small{(a)}
\end{minipage}
%
\begin{minipage}[t]{0.37\linewidth}
\begin{lstlisting}
var int tot = 10000; // 10ms
loop do
    await DT;
    tot = tot - DT_;
    if tot <= 0 then
        dt = -tot;
        break;
    end
end
.
\end{lstlisting}
\centering\small{(b)}
\end{minipage}
%
\begin{minipage}[t]{0.30\linewidth}
\begin{lstlisting}
mem;
loop(
    await(DT);
    mem;
    if mem then
        mem;
        break
    else
        nop
)
\end{lstlisting}
\centering\small{(c)}
\end{minipage}
\caption{
Two-step translation from concrete to abstract timer.
\label{lst.map.timers.2}
}
\end{figure}

\subsubsection{Finalization Blocks}
\label{sec.formal.fins}

The biggest mismatch between concrete and abstract \CEU is regarding the 
\code{finalize} blocks, which require more complex modifications in the program
for a proper mapping using $fin$ expressions.
In the three-step translation in Figure~\ref{lst.map.fin}, we start with a 
concrete program (a) that uses a \code{finalize} to safely \code{\_release} the 
reference to \code{ptr} kept after the call to \code{\_hold}.
In the translation, we first need to catch the outermost \code{do-end} 
termination to run the finalization code.
For this, we translate the block into a \code{par/or} (b) with the original 
body in parallel with a $fin$ expression to run the finalization code.
Note that the $fin$ has no transition rules in the semantics, keeping the 
\code{par/or} alive.
This way, the $fin$ body only executes when the \code{par/or} terminates either 
normally (after the \code{await B}), or aborted from an outer composition.
%
However, the $fin$ still (incorrectly) executes even if the call to 
\code{\_hold} is not reached in the body due to an abort before awaking from 
the \code{await A}.
%
To deal with this issue, for each $fin$ we need a corresponding flag to keep 
track of code that needs to be finalized (c).
%
The flag is initially set to false, avoiding the finalization code to execute.
Only after the call to \code{\_hold} that we set the flag to true and enable 
the $fin$ body to execute.
%
The complete translation substitutes the side-effect operations with $mem$ 
expressions (d).

\begin{figure}
\begin{minipage}[t]{0.26\linewidth}
\begin{lstlisting}
do
  var int* ptr = <...>;
  await A;
  finalize
    _hold(ptr);
  with
    _release(ptr);
  end
  await B;
end



.
\end{lstlisting}
\centering\small{(a)}
\end{minipage}
%
\begin{minipage}[t]{0.26\linewidth}
\begin{lstlisting}
par/or do
  var int* ptr = <...>;
  await A;
  _hold(ptr);
  await B;
with
  { fin
      _release(ptr); }
end




.
\end{lstlisting}
\centering\small{(b)}
\end{minipage}
%
\begin{minipage}[t]{0.26\linewidth}
\begin{lstlisting}
f_ = 0;
par/or do
  var int* ptr = <...>;
  await A;
  _hold(ptr);
  f_ = 1;
  await B;
with
  { fin
      if f_ then
        _release(ptr);
      end }
end
.
\end{lstlisting}
\centering\small{(c)}
\end{minipage}
%
\begin{minipage}[t]{0.18\linewidth}
\begin{lstlisting}
mem;
(
   mem;
   await(A);
   mem;
   mem;
   await(B);
or
   fin
     if mem then
       mem
     else
       nop
)
\end{lstlisting}
\centering\small{(d)}
\end{minipage}
%
\caption{
Three-step translation from concrete to abstract finalization.
\label{lst.map.fin}
}
\end{figure}
